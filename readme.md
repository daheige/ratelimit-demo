# rate-limit
推荐使用：golang.org/x/time/rate
- 速率限制是构建可扩展和弹性系统的关键技术。它通过对指定时间范围内允许的请求数量施加限制来帮助控制流量。
- 在Go语言中，实现速率限制可以确保最佳的资源利用，并保护您的应用程序免受过度流量或滥用行为的影响。

# 适应场景
- API请求速率控制（如第三方接口调用）
- 高并发服务防止资源过载（如数据库访问）
- 平滑突发流量，避免服务崩溃‌

# 实现原理
速率限制包括定义一组规则，这些规则决定客户端在给定的时间窗口内可以发出多少请求。
确保系统能够处理负载，防止滥用或拒绝服务攻击。限制速率的两种常见方法是:
- 固定窗口速率限制:在这种方法中，速率限制在固定的时间窗口内强制执行。例如，如果速率限制设置为每分钟100个请求，系统将在任何给定的60秒窗口中允许最多100个请求。超过此限制的请求将被拒绝或延迟到下一个时间窗口。
- 令牌桶速率限制:令牌桶速率限制是基于从一个桶中消耗令牌的概念。桶最初由固定数量的令牌填充，每个令牌代表一个请求。当客户端想要发出请求时，它必须从桶中获取令牌。如果桶为空，客户端必须等待，直到令牌可用。

# 使用方式
通过 rate.NewLimiter(limit, burst) 创建令牌桶限流器：
- limit‌：令牌填充速率，支持两种形式：
  - 直接指定每秒令牌数，如 rate.Limit(10) 表示每秒填充10个令牌。
  - 使用 rate.Every(interval) 指定时间间隔，例如 rate.Every(100*time.Millisecond) 等价于每秒10个令牌‌。
- burst‌：令牌桶容量，控制瞬时允许的最大请求量‌

示例：
```go
limiter := rate.NewLimiter(rate.Every(200*time.Millisecond), 5)  // 每200ms填充1个令牌，桶容量5
```

# 核心方法
- 立即判断：Allow()/AllowN()
  - 检查当前是否有足够令牌，返回布尔值（非阻塞）。
  - 适用于需快速丢弃超限请求的场景‌

示例：
```go
if limiter.Allow() {
    // 处理请求
} else {
    // 触发限流逻辑
}
```
- 阻塞等待 Wait()/WaitN()
  - 阻塞当前协程直至获取足够令牌（支持 context 超时控制）。
  - 适用于需严格限制速率的场景（如API调用）

示例：
```go
err := limiter.WaitN(context.Background(), 3)  // 等待获取3个令牌
if err == nil {
    // 执行操作
}
```
- 预约令牌：Reserve()/ReserveN()
- 返回 Reservation 对象，可获取实际需等待的时间
- 适用于需精确控制延迟或批量处理的场景‌

示例：
```go
res := limiter.ReserveN(time.Now(), 2)
if !res.OK() {
    return // 无法满足请求
}
time.Sleep(res.Delay())  // 等待至令牌可用
// 执行操作
```
具体选择取决于是否需要阻塞、是否需要精确控制等待时间等需求‌。

# 动态调整参数
1. SetLimit(newLimit)‌：修改令牌填充速率‌
2. SetBurst(newBurst)‌：调整令牌桶容量‌

示例：
```go
limiter.SetLimit(rate.Limit(20))  // 将速率提高到每秒20个令牌
```
解说：
- rate.Limiter 提供了 SetLimit 和 SetBurst 两个方法来动态调整限制器的速率和桶大小。
- SetLimit(rate.Limit): 这个方法用来设置每秒可以生成的令牌数。rate.Limit 是一个基于浮点数的类型，用来表示每秒允许的事件数。
- SetBurst(int): 这个方法用来设置限制器的桶大小。桶大小决定了在任何给定时间内限制器可以允许的最大事件数。

动态调整的优势：
- 动态调整，允许你在运行时根据需要改变速率限制。这在很多实际应用中非常有用，比如基于当前服务器负载或外部服务的可用性来调整请求速率。
- 自适应速率限制可根据之前请求的响应时间或错误率动态调整速率限制。它允许系统自动适应不同的流量条件，确保最佳性能和资源利用率。

# 小结
rate.Limiter 的使用场景体现了其灵活性和实用性。
- 无论是保护外部服务不被过载、控制资源访问、还是提高应用的整体稳定性，它都是一个非常有效的工具。
- 在设计系统时，考虑到这些场景，合理地应用速率限制，可以显著提升系统的健壮性和用户体验。
